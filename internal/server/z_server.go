// Code generated by mykit. DO NOT EDIT.
// Version v1.7.0

package server

import (
	"context"
	"fmt"
	"net"
	"os"
	grpcctxtags "github.com/grpc-ecosystem/go-grpc-middleware/tags"
	config "arceus/pkg/carbon/pkg/config"
	"arceus/pkg/logger/pkg/logging"
	"go.uber.org/zap"
	"google.golang.org/grpc"
	"google.golang.org/grpc/health"
	healthv1 "google.golang.org/grpc/health/grpc_health_v1"
	"google.golang.org/grpc/metadata"
	mykit "arceus/pkg/mykit/pkg/api"

	conf "arceus/pkg/config"
)

func Run(f *config.Flags) {
	cfg := loadConfig(f)
	Serve(cfg)
}

func newService(cfg *conf.Config, opts ...mykit.Option) mykit.Service {
	listener, err := net.Listen("tcp", fmt.Sprintf("%s:%d", cfg.Listener.GetTcp().Address, cfg.Listener.GetTcp().Port))
	if err != nil {
		logging.NewTmpLogger().Fatal("failed to new listener", zap.Error(err))
	}

	logger := logging.Logger(context.Background())

	healthServer := health.NewServer()
	healthServer.SetServingStatus("", healthv1.HealthCheckResponse_SERVING)

	defaultOpts := []mykit.Option{
		mykit.Logger(logger),
		mykit.Listener(listener),
		mykit.ServerOptions(
			grpc.ChainUnaryInterceptor(
				grpcctxtags.UnaryServerInterceptor(grpcctxtags.WithFieldExtractor(grpcctxtags.CodeGenRequestFieldExtractor)),
			),
		),
		mykit.HealthServer(healthServer),
	}

	httpListener, err := net.Listen("tcp", fmt.Sprintf("%s:%d", cfg.HttpListener.GetTcp().Address, cfg.HttpListener.GetTcp().Port))
	if err != nil {
		logging.NewTmpLogger().Fatal("failed to new http listener", zap.Error(err))
	}
	httpListenerOption := mykit.HttpListener(httpListener)
	defaultOpts = append(defaultOpts, httpListenerOption)

	svc := mykit.NewService(append(defaultOpts, opts...)...)
	return svc
}

func GetRequestID(ctx context.Context) string {
	md, ok := metadata.FromIncomingContext(ctx)
	if !ok {
		return ""
	}
	mdUserID := md.Get("x-request-id")
	if len(mdUserID) < 1 {
		return ""
	}
	return mdUserID[0]
}

func loadConfig(f *config.Flags) *conf.Config {
	// Use a temporary logger to parse the configuration and output.
	tmpLogger := logging.NewTmpLogger().With(zap.String("filename", f.ConfigPath))

	var cfg conf.Config
	if err := config.ParseFile(f.ConfigPath, &cfg, f.Template); err != nil {
		tmpLogger.Fatal("parsing configuration failed", zap.Error(err))
	}

	if err := cfg.Validate(); err != nil {
		tmpLogger.Fatal("validating configuration failed", zap.Error(err))
	}

	if f.Validate {
		tmpLogger.Info("configuration validation was successful")
		os.Exit(0)
	}

	return &cfg
}
